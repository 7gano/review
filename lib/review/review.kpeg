%% name = ReVIEW::Compiler

%% {
  class Error; end

require 'review/location'
require 'review/extentions'
require 'review/preprocessor'
require 'review/exception'
require 'review/node'
  require 'lineinput'
  if RUBY_VERSION > '1.9' then
    require 'review/compiler/literals_1_9'
  else
    require 'review/compiler/literals_1_8'
  end

  ## redifine Compiler.new
  def initialize(strategy)
    @strategy = strategy
  end

  attr_accessor :strategy

    def compile(chap)
      @chapter = chap
      do_compile
      @strategy.result
    end

    def do_compile
      @strategy.bind self, @chapter, ReVIEW::Location.new(@chapter.basename, self)
      setup_parser(@chapter.content)
      parse()
      convert_ast
    end

    def convert_ast
      ast = @strategy.ast
      convert_column(ast)
      @strategy.output << ast.to_doc
    end

    def flush_column(new_content)
      if @current_column
        new_content << @current_column
        @current_column = nil
      end
    end

    def convert_column(ast)
      @column_stack = []
      content = ast.content
      new_content = []
      @current_content = new_content
      content.each do |elem|
        if elem.kind_of?(ReVIEW::HeadlineNode) && elem.cmd && elem.cmd.to_doc == "column"
          flush_column(new_content)
          @current_content = []
          @current_column = ReVIEW::ColumnNode.new(elem.compiler, elem.level,
                                                  elem.label, elem.content, @current_content)
          next
        elsif elem.kind_of?(ReVIEW::HeadlineNode) && elem.cmd && elem.cmd.to_doc =~ %r|^/|
          cmd_name = elem.cmd.to_doc[1..-1]
          if cmd_name != "column"
            raise ReVIEW::CompileError, "#{cmd_name} is not opened."
          end
          flush_column(new_content)
          @current_content = new_content
          next
        elsif elem.kind_of?(ReVIEW::HeadlineNode) && @current_column && elem.level <= @current_column.level
          flush_column(new_content)
          @current_content = new_content
        end
        @current_content << elem
      end
      flush_column(new_content)
      ast.content = new_content
      ast
    end

    def compile_text(text)
      @strategy.nofunc_text(text)
    end

    class SyntaxElement
      def initialize(name, type, argc, esc, &block)
        @name = name
        @type = type
        @argc_spec = argc
        @esc_patterns = esc
        @checker = block
      end

      attr_reader :name

      def check_args(args)
        unless @argc_spec === args.size
          raise ReVIEW::CompileError, "wrong # of parameters (block command //#{@name}, expect #{@argc_spec} but #{args.size})"
        end
        @checker.call(*args) if @checker
      end

      def min_argc
        case @argc_spec
        when Range then @argc_spec.begin
        when Integer then @argc_spec
        else
          raise TypeError, "argc_spec is not Range/Integer: #{inspect()}"
        end
      end

      def parse_args(args)
        if @esc_patterns
          args.map.with_index do |pattern, i|
            if @esc_patterns[i]
              args[i].__send__("to_#{@esc_patterns[i]}")
            else
              args[i].to_doc
            end
          end
        else
          args.map(&:to_doc)
        end
      end

      def block_required?
        @type == :block or @type == :code_block
      end

      def block_allowed?
        @type == :block or @type == :code_block or @type == :optional or @type == :optional_code_block
      end

      def code_block?
        @type == :code_block or @type == :optional_code_block
      end
    end

    SYNTAX = {}

    def self.defblock(name, argc, optional = false, esc = nil, &block)
      defsyntax(name, (optional ? :optional : :block), argc, esc, &block)
    end

    def self.defcodeblock(name, argc, optional = false, esc = nil, &block)
      defsyntax(name, (optional ? :optional_code_block : :code_block), argc, esc, &block)
    end

    def self.defsingle(name, argc, &block)
      defsyntax name, :line, argc, &block
    end

    def self.defsyntax(name, type, argc, esc = nil, &block)
      SYNTAX[name] = SyntaxElement.new(name, type, argc, esc, &block)
    end

    def syntax_defined?(name)
      SYNTAX.key?(name.to_sym)
    end

    def syntax_descriptor(name)
      SYNTAX[name.to_sym]
    end

    class InlineSyntaxElement
      def initialize(name)
        @name = name
      end

      attr_reader :name
    end

    INLINE = {}

    def self.definline(name)
      INLINE[name] = InlineSyntaxElement.new(name)
    end

    def inline_defined?(name)
      INLINE.key?(name.to_sym)
    end

    defblock :read, 0
    defblock :lead, 0
    defblock :quote, 0
    defblock :bibpaper, 2..3, true
    defblock :doorquote, 1
    defblock :talk, 0
    defblock :graph, 1..3

    defcodeblock :emlist, 0..1
    defcodeblock :cmd, 0..1
    defcodeblock :source, 0..1
    defcodeblock :list, 2, nil
    defcodeblock :listnum, 2
    defcodeblock :emlistnum, 0..1
    defcodeblock :texequation, 0
    defcodeblock :table, 0..2
    defcodeblock :image, 2..3, true, [:raw,:doc,:raw]
    defcodeblock :box, 0..1

    defblock :address, 0
    defblock :blockquote, 0
    defblock :bpo, 0
    defblock :flushright, 0
    defblock :centering, 0
    defblock :note, 0..1
    defblock :comment, 0..1, true

    defsingle :footnote, 2
    defsingle :noindent, 0
    defsingle :linebreak, 0
    defsingle :pagebreak, 0
    defsingle :indepimage, 1..3
    defsingle :numberlessimage, 1..3
    defsingle :hr, 0
    defsingle :parasep, 0
    defsingle :label, 1
    defsingle :raw, 1
    defsingle :tsize, 1
    defsingle :include, 1
    defsingle :olnum, 1

    definline :chapref
    definline :chap
    definline :title
    definline :img
    definline :imgref
    definline :icon
    definline :list
    definline :table
    definline :fn
    definline :kw
    definline :ruby
    definline :bou
    definline :ami
    definline :b
    definline :dtp
    definline :code
    definline :bib
    definline :hd
    definline :href
    definline :recipe
    definline :column

    definline :abbr
    definline :acronym
    definline :cite
    definline :dfn
    definline :em
    definline :kbd
    definline :q
    definline :samp
    definline :strong
    definline :var
    definline :big
    definline :small
    definline :del
    definline :ins
    definline :sup
    definline :sub
    definline :tt
    definline :i
    definline :tti
    definline :ttb
    definline :u
    definline :raw
    definline :br
    definline :m
    definline :uchar
    definline :idx
    definline :hidx
    definline :comment
    definline :include


    def compile_column(level, label, caption, content)
      buf = ""
      buf << @strategy.__send__("column_begin", level, label, caption)
      buf << content.to_doc
      buf << @strategy.__send__("column_end", level)
      buf
    end

    def compile_command(name, args, lines, node)
      syntax = syntax_descriptor(name)
      if !syntax || (!@strategy.respond_to?(syntax.name) && !@strategy.respond_to?("node_#{syntax.name}"))
        error "strategy does not support command: //#{name}"
        compile_unknown_command args, lines
        return
      end
      begin
        syntax.check_args args
      rescue ReVIEW::CompileError => err
        error err.message
        args = ['(NoArgument)'] * syntax.min_argc
      end
      if syntax.block_allowed?
        compile_block(syntax, args, lines, node)
      else
        if lines
          error "block is not allowed for command //#{syntax.name}; ignore"
        end
        compile_single(syntax, args, node)
      end
    end

    def compile_headline(level, tag, label, caption)
      buf = ""
      @headline_indexs ||= [0] ## XXX
      caption ||= ""
      caption.strip!
      index = level - 1
      if @headline_indexs.size > (index + 1)
        @headline_indexs = @headline_indexs[0..index]
      end
      @headline_indexs[index] = 0 if @headline_indexs[index].nil?
      @headline_indexs[index] += 1
      buf << @strategy.headline(level, label, caption)
      buf
    end

    def comment(text)
      @strategy.comment(text)
    end

    def compile_ulist(content)
      buf0 = ""
      level = 0
      content.each do |element|
        current_level, buf = element.level, element.to_doc
        if level == current_level
          buf0 << @strategy.ul_item_end
          # body
          buf0 << @strategy.ul_item_begin([buf])
        elsif level < current_level # down
          level_diff = current_level - level
          level = current_level
          (1..(level_diff - 1)).to_a.reverse.each do |i|
            buf0 << @strategy.ul_begin{i}
            buf0 << @strategy.ul_item_begin([])
          end
          buf0 << @strategy.ul_begin{level}
          buf0 << @strategy.ul_item_begin([buf])
        elsif level > current_level # up
          level_diff = level - current_level
          level = current_level
          (1..level_diff).to_a.reverse.each do |i|
            buf0 << @strategy.ul_item_end
            buf0 << @strategy.ul_end{level + i}
          end
          buf0 << @strategy.ul_item_end
          # body
          buf0 <<@strategy.ul_item_begin([buf])
        end
      end

      (1..level).to_a.reverse.each do |i|
        buf0 << @strategy.ul_item_end
        buf0 << @strategy.ul_end{i}
      end
      buf0
    end

    def compile_olist(content)
      buf0 = ""
      buf0 << @strategy.ol_begin
      content.each do |element|
        ## XXX 1st arg should be String, not Array
        buf0 << @strategy.ol_item(element.to_doc.split(/\n/), element.num)
      end
      buf0 << @strategy.ol_end
      buf0
    end

    def compile_dlist(content)
      buf = ""
      buf << @strategy.dl_begin
      content.each do |element|
        buf << @strategy.dt(element.text.to_doc)
        buf << @strategy.dd(element.content.map{|s| s.to_doc})
      end
      buf << @strategy.dl_end
      buf
    end


    def compile_unknown_command(args, lines)
      @strategy.unknown_command(args, lines)
    end

    def compile_block(syntax, args, lines, node)
      node_name = "node_#{syntax.name}".to_sym
      if @strategy.respond_to?(node_name)
        @strategy.__send__(node_name, node)
      else
        args_conv = syntax.parse_args(args)
        @strategy.__send__(syntax.name, (lines || default_block(syntax)), *args_conv)
      end
    end

    def default_block(syntax)
      if syntax.block_required?
        error "block is required for //#{syntax.name}; use empty block"
      end
      []
    end

    def compile_single(syntax, args, node)
      node_name = "node_#{syntax.name}".to_sym
      if @strategy.respond_to?(node_name)
        @strategy.__send__(node_name, node)
      else
        args_conv = syntax.parse_args(args)
        @strategy.__send__(syntax.name, *args_conv)
      end
    end


    def compile_inline(op, args)
      unless inline_defined?(op)
        raise ReVIEW::CompileError, "no such inline op: #{op}"
      end
      if @strategy.respond_to?("node_inline_#{op}")
        return @strategy.__send__("node_inline_#{op}", args)
      end
      unless @strategy.respond_to?("inline_#{op}")
        raise "strategy does not support inline op: @<#{op}>"
      end
      if !args
        @strategy.__send__("inline_#{op}", "")
      else
        @strategy.__send__("inline_#{op}", *(args.map(&:to_doc)))
      end
    rescue => err
      error err.message
    end

    def compile_paragraph(buf)
      @strategy.paragraph buf
    end

    def compile_raw(builders, content)
      c = @strategy.class.to_s.gsub(/ReVIEW::/, '').gsub(/Builder/, '').downcase
      if !builders || builders.include?(c)
        content.gsub("\\n", "\n")
      else
        ""
      end
    end

    def warn(msg)
      @strategy.warn msg
    end

    def error(msg)
      @strategy.error msg
    end


}

%% ast-location = ::ReVIEW
%% headline = ast HeadlineNode(compiler, level, cmd, label, content)
%% paragraph = ast ParagraphNode(compiler, content)
%% block_element = ast BlockElementNode(compiler, name, args, content)
%% code_block_element = ast CodeBlockElementNode(compiler, name, args, content)
%% inline_element = ast InlineElementNode(compiler, symbol, content)
%% inline_element_content = ast InlineElementContentNode(compiler, content)
%% text = ast TextNode(compiler, content)
%% raw = ast RawNode(compiler, builder, content)
%% brace = ast BraceNode(compiler, content)
%% singleline_content = ast SinglelineContentNode(compiler, content)
%% singleline_comment = ast SinglelineCommentNode(compiler, content)
%% ulist = ast UlistNode(compiler, content)
%% ulist_element = ast UlistElementNode(compiler, level, content)
%% olist = ast OlistNode(compiler, content)
%% olist_element = ast OlistElementNode(compiler, num, content)
%% dlist = ast DlistNode(compiler, content)
%% dlist_element = ast DlistElementNode(compiler, text, content)
%% bracket_arg = ast BracketArgNode(compiler, content)
%% document = ast DocumentNode(compiler, content)
%% column = ast ColumnNode(compiler, level, label, caption, content)
%% newline = ast NewLineNode(compiler, content)

# %% dummy

root = Start

Start = &. Document:c { @strategy.ast = c }

Document = Block*:c ~document(self, c)

## TODO InlineElement の後に Ulist / Olist / Dlist が来ると先頭行じゃなくてマッチできてしまうかも
## using &. to detect EOF
Block = BlankLine*:c { c }
        ( SinglelineComment:c
        | Headline:c
        | BlockElement:c
        | Ulist:c
        | Olist:c
        | Dlist:c
        | Paragraph:c
        ) { c }

BlankLine = Newline

SinglelineComment = ("#@" < NonNewLine+ > EOL) ~singleline_comment(self, text)

Headline =  HeadlinePrefix:level BracketArg?:cmd BraceArg?:label Space*  SinglelineContent?:caption EOL  ~headline(self, level, cmd, label, caption)

HeadlinePrefix = < /={1,5}/ > { text.length }

Paragraph = ParagraphSub+:c  ~paragraph(self, c.flatten)

ParagraphSub = !Headline !SinglelineComment !BlockElement !Ulist !Olist !Dlist  SinglelineContent:c Newline { c }

BlockElement = ( "//raw[" RawBlockBuilderSelect?:b RawBlockElementArg*:r1 "]" Space* EOL
                 ~raw(self, b, r1)
               | !"//raw" "//" ElementName:symbol &{ syntax = syntax_descriptor(symbol); syntax && syntax.code_block? } BracketArg*:args "{" Space* Newline CodeBlockElementContents?:contents "//}" Space* EOL
                  ~code_block_element(self, symbol, args, contents)
               | !"//raw" "//" ElementName:symbol BracketArg*:args "{" Space* Newline BlockElementContents?:contents "//}" Space* EOL
                  ~block_element(self, symbol, args, contents)
               | !"//raw" "//" ElementName:symbol BracketArg*:args Space* EOL ~block_element(self, symbol, args, nil)
               )

RawBlockBuilderSelect = "|" Space* RawBlockBuilderSelectSub:c Space* "|" { c }

RawBlockBuilderSelectSub = ( < AlphanumericAscii+ >:c1 Space* "," Space* RawBlockBuilderSelectSub:c2
                             { [text] + c2 }
                           | < AlphanumericAscii+ >:c1
                             { [text] }
                           )

RawBlockElementArg = !"]" ( "\\]" { "]" }
                          | "\\n" { "\n" }
                          | < NonNewLine >  { text }
                          )

BracketArg = "["  BracketArgContentInline*:content  "]" ~bracket_arg(self, content)

## XXX '\' (excpet '\]' and '\\' ) => '\' is ???
BracketArgContentInline = ( InlineElement:c { c }
                          |  "\\]" ~text(self, "]")
                          | "\\\\" ~text(self, "\\")
                          | < /[^\r\n\]]/ >  ~text(self, text)
                          )

BraceArg = "{" < /([^\r\n}\\]|\\[^\r\n])*/ > "}" { text }

## contents との差は paragraph を切るか切らないか
BlockElementContents = BlockElementContent+:c { c }

## 各要素は Newline で終わらなければならない
### SinglelineContentではないような気がするけど改行は落としてあるのでとりあえずこれで
BlockElementContent = ( SinglelineComment:c { c }
                      | BlockElement:c { c }
                      | Ulist:c
                      | Olist:c
                      | BlankLine:c { c }
                      | BlockElementParagraph:c { c }
                      )

## it's like Paragraph, but it's in a block, so do not allow '//}\n'
BlockElementParagraph = BlockElementParagraphSub+:c  ~paragraph(self, c.flatten)
BlockElementParagraphSub = !"//}" !BlankLine !SinglelineComment !BlockElement !Ulist !Olist !Dlist SinglelineContent:c Newline:n { [c, n] }

## In CodeBlockElementContents, newline should no be ingored. So we use TextNode instead of NewLineNode.
CodeBlockElementContents = CodeBlockElementContent+:c { c }
CodeBlockElementContent = ( SinglelineComment:c { c }
                          | BlankLine:c { ::ReVIEW::TextNode.new(self, "\n") }
                          | !"//}" SinglelineContent:c Newline:n { [c, ::ReVIEW::TextNode.new(self, "\n")] }
                          )

## * 箇条書き
## 行頭から… の指定がない

Ulist =  &. { @ulist_elem=[] } UlistElement (UlistElement | UlistContLine | SinglelineComment)+ ~ulist(self, @ulist_elem)

UlistElement = " "+ "*"+:level " "* SinglelineContent:c EOL { @ulist_elem << ::ReVIEW::UlistElementNode.new(self, level.size, [c]) }
UlistContLine = " " " "+ !"*" SinglelineContent:c EOL {  @ulist_elem[-1].concat(c) }

## 1. 番号付き箇条書き
## 行頭から… の指定がない

Olist = { @olist_elem = [] } (OlistElement | SinglelineComment)+:c ~olist(self, @olist_elem)

OlistElement = " "+ < /\d/+ > { num=text } "." Space* SinglelineContent:c EOL {@olist_elem << ReVIEW::OlistElementNode.new(self, num.to_i, [c]) }

## : 用語リスト
  ## 行頭から… の指定がない
Dlist = (DlistElement | SinglelineComment)+:content ~dlist(self, content)

DlistElement = " "* ":" " " Space* SinglelineContent:text Newline DlistElementContent+:content ~dlist_element(self, text, content)

DlistElementContent = /[ \t]+/ SinglelineContent:c Newline:n { c }

SinglelineContent = Inline+:c ~singleline_content(self,c)

Inline = ( InlineElement | NonInlineElement)

NonInlineElement = !InlineElement < NonNewLine > ~text(self, text)

InlineElement =  ( RawInlineElement:c { c }
                 | !RawInlineElement "@<" InlineElementSymbol:symbol ">" "{" InlineElementContents?:contents "}" ~inline_element(self, symbol,contents)
                 )

RawInlineElement = "@<raw>{" RawBlockBuilderSelect?:builders RawInlineElementContent+:c "}" ~raw(self, builders,c)

RawInlineElementContent = ( "\\}" { "}" }
                          | < /[^\r\n\}]/ >  { text }
                          )

InlineElementSymbol = < AlphanumericAscii+ > { text }

InlineElementContents = !"}" InlineElementContentsSub:c { c }

InlineElementContentsSub = !"}" ( InlineElementContent:c1 Space* "," Space* InlineElementContentsSub:c2 {  [c1]+c2 }
                                | InlineElementContent:c1 { [c1] }
                                )


InlineElementContent = InlineElementContentSub+:d { d }

InlineElementContentSub = ( InlineElement:c { c }
                          | !InlineElement InlineElementContentText+:content ~inline_element_content(self, content)
                          )

## XXX '\' (excpet '\}' and '\,' and '\\' ) => '\' is OK?
InlineElementContentText =  ( "\\}" ~text(self, "}")
                            | "\\," ~text(self, ",")
                            | "\\\\" ~text(self, "\\" )
                            | "\\" ~text(self, "\\" )
                            | !InlineElement < /[^\r\n\\},]/> ~text(self,text)
                            )

NonNewLine = /[^\r\n]/

Digits = Digit+:c { c }

## Space = /[ 　\t]/
Space = /[ \t]/

EOL = (Newline|EOF)

EOF = !.

ElementName = < LowerAlphabetAscii+ > { text }

%literals         = ReVIEW::Compiler::Literals
Alphanumeric      = %literals.Alphanumeric
AlphanumericAscii = %literals.AlphanumericAscii
LowerAlphabetAscii = %literals.LowerAlphabetAscii
Digit              = %literals.Digit
BOM               = %literals.BOM
Newline           = %literals.Newline:n ~newline(self, "\n")
NonAlphanumeric   = %literals.NonAlphanumeric
Spacechar         = %literals.Spacechar
