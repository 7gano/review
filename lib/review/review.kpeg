%% name = ReVIEW::Compiler

%% {

  class Error; end

require 'review/location'
require 'review/extentions'
require 'review/preprocessor'
require 'review/exception'
  require 'lineinput'
  if RUBY_VERSION > '1.9' then
    require 'review/compiler/literals_1_9'
  else
    require 'review/compiler/literals_1_8'
  end

  ## redifine Compiler.new
  def initialize(strategy)
    @strategy = strategy
  end

  attr_accessor :strategy

    def compile(chap)
      @chapter = chap
      do_compile
      @strategy.result
    end

    def do_compile
      f = LineInput.new(ReVIEW::Preprocessor::Strip.new(StringIO.new(@chapter.content)))
      @strategy.bind self, @chapter, ReVIEW::Location.new(@chapter.basename, f)
      setup_parser(@chapter.content)
      parse()
    end

    def text(str)
      st = @strategy.dup
      f = LineInput.new(ReVIEW::Preprocessor::Strip.new(StringIO.new(str)))
      st.bind self, @chapter, ReVIEW::Location.new(@chapter.basename, f)
      parser = ReVIEW::Compiler.new(st)
      parser.setup_parser(str)
      parser.parse("InlineElementContents")
      st.result
    end

    class SyntaxElement
      def initialize(name, type, argc, &block)
        @name = name
        @type = type
        @argc_spec = argc
        @checker = block
      end

      attr_reader :name

      def check_args(args)
        unless @argc_spec === args.size
          raise CompileError, "wrong # of parameters (block command //#{@name}, expect #{@argc_spec} but #{args.size})"
        end
        @checker.call(*args) if @checker
      end

      def min_argc
        case @argc_spec
        when Range then @argc_spec.begin
        when Integer then @argc_spec
        else
          raise TypeError, "argc_spec is not Range/Integer: #{inspect()}"
        end
      end

      def block_required?
        @type == :block
      end

      def block_allowed?
        @type == :block or @type == :optional
      end
    end

    SYNTAX = {}

    def self.defblock(name, argc, optional = false, &block)
      defsyntax name, (optional ? :optional : :block), argc, &block
    end

    def self.defsingle(name, argc, &block)
      defsyntax name, :line, argc, &block
    end

    def self.defsyntax(name, type, argc, &block)
      SYNTAX[name] = SyntaxElement.new(name, type, argc, &block)
    end

    def syntax_defined?(name)
      SYNTAX.key?(name.to_sym)
    end

    def syntax_descriptor(name)
      SYNTAX[name.to_sym]
    end

    class InlineSyntaxElement
      def initialize(name)
        @name = name
      end

      attr_reader :name
    end

    INLINE = {}

    def self.definline(name)
      INLINE[name] = InlineSyntaxElement.new(name)
    end

    def inline_defined?(name)
      INLINE.key?(name.to_sym)
    end

    defblock :read, 0
    defblock :lead, 0
    defblock :list, 2
    defblock :emlist, 0..1
    defblock :cmd, 0..1
    defblock :table, 0..2
    defblock :quote, 0
    defblock :image, 2..3, true
    defblock :source, 0..1
    defblock :listnum, 2
    defblock :emlistnum, 0..1
    defblock :bibpaper, 2..3, true
    defblock :doorquote, 1
    defblock :talk, 0
    defblock :texequation, 0
    defblock :graph, 1..3

    defblock :address, 0
    defblock :blockquote, 0
    defblock :bpo, 0
    defblock :flushright, 0
    defblock :centering, 0
    defblock :note, 0..1
    defblock :box, 0..1
    defblock :comment, 0..1, true

    defsingle :footnote, 2
    defsingle :noindent, 0
    defsingle :linebreak, 0
    defsingle :pagebreak, 0
    defsingle :indepimage, 1..3
    defsingle :numberlessimage, 1..3
    defsingle :hr, 0
    defsingle :parasep, 0
    defsingle :label, 1
    defsingle :raw, 1
    defsingle :tsize, 1
    defsingle :include, 1
    defsingle :olnum, 1

    definline :chapref
    definline :chap
    definline :title
    definline :img
    definline :icon
    definline :list
    definline :table
    definline :fn
    definline :kw
    definline :ruby
    definline :bou
    definline :ami
    definline :b
    definline :dtp
    definline :code
    definline :bib
    definline :hd
    definline :href
    definline :recipe

    definline :abbr
    definline :acronym
    definline :cite
    definline :dfn
    definline :em
    definline :kbd
    definline :q
    definline :samp
    definline :strong
    definline :var
    definline :big
    definline :small
    definline :del
    definline :ins
    definline :sup
    definline :sub
    definline :tt
    definline :i
    definline :tti
    definline :ttb
    definline :u
    definline :raw
    definline :br
    definline :m
    definline :uchar
    definline :idx
    definline :hidx
    definline :comment
    definline :include


    def tagged_section_init
      @tagged_section = []
    end

    def open_tagged_section(tag, level, label, caption)
      mid = "#{tag}_begin"
      unless @strategy.respond_to?(mid)
        error "strategy does not support tagged section: #{tag}"
        return
      end
      @tagged_section.push [tag, level]
      @strategy.__send__ mid, level, label, caption
    end

    def close_tagged_section(tag, level)
      mid = "#{tag}_end"
      if @strategy.respond_to?(mid)
        @strategy.__send__ mid, level
      else
        error "strategy does not support block op: #{mid}"
      end
    end

    def close_all_tagged_section
      until @tagged_section.empty?
        close_tagged_section(* @tagged_section.pop)
      end
    end

    def compile_command(name, args, lines)
          syntax = syntax_descriptor(name)
      unless @strategy.respond_to?(syntax.name)
        error "strategy does not support command: //#{syntax.name}"
        compile_unknown_command args, lines
        return
      end
      begin
        syntax.check_args args
      rescue CompileError => err
        error err.message
        args = ['(NoArgument)'] * syntax.min_argc
      end
      if syntax.block_allowed?
        compile_block syntax, args, lines
      else
        if lines
          error "block is not allowed for command //#{syntax.name}; ignore"
        end
        compile_single syntax, args
      end
    end

    def compile_headline(level, tag, label, caption)
      @headline_indexs ||= [0] ## XXX
      caption.strip!
      index = level - 1
      if tag
        if tag !~ /\A\//
          close_current_tagged_section(level)
          open_tagged_section(tag, level, label, caption)
        else
          open_tag = tag[1..-1]
          prev_tag_info = @tagged_section.pop
          unless prev_tag_info.first == open_tag
            raise CompileError, "#{open_tag} is not opened."
          end
          close_tagged_section(*prev_tag_info)
        end
      else
        if @headline_indexs.size > (index + 1)
          @headline_indexs = @headline_indexs[0..index]
        end
        @headline_indexs[index] = 0 if @headline_indexs[index].nil?
        @headline_indexs[index] += 1
        close_current_tagged_section(level)
        @strategy.headline level, label, caption
      end
    end

    def close_current_tagged_section(level)
      while @tagged_section.last and @tagged_section.last[1] >= level
        close_tagged_section(* @tagged_section.pop)
      end
    end

    def comment(text)
      @strategy.comment(text)
    end

    def compile_ulist(elem)
      level = 0
      elem.each do |current_level, buf|
        if level == current_level
          @strategy.ul_item_end
          # body
          @strategy.ul_item_begin [buf]
        elsif level < current_level # down
          level_diff = current_level - level
          level = current_level
          (1..(level_diff - 1)).to_a.reverse.each do |i|
            @strategy.ul_begin {i}
            @strategy.ul_item_begin []
          end
          @strategy.ul_begin {level}
          @strategy.ul_item_begin [buf]
        elsif level > current_level # up
          level_diff = level - current_level
          level = current_level
          (1..level_diff).to_a.reverse.each do |i|
            @strategy.ul_item_end
            @strategy.ul_end {level + i}
          end
          @strategy.ul_item_end
          # body
          @strategy.ul_item_begin [buf]
        end
      end

      (1..level).to_a.reverse.each do |i|
        @strategy.ul_item_end
        @strategy.ul_end {i}
      end
    end

    def compile_olist(elem)
      @strategy.ol_begin
      elem.each do |num, buf|
        @strategy.ol_item buf, num
      end
      @strategy.ol_end
    end


    def compile_unknown_command(args, lines)
      @strategy.unknown_command args, lines
    end

    def compile_block(syntax, args, lines)
      @strategy.__send__(syntax.name, (lines || default_block(syntax)), *args)
    end

    def default_block(syntax)
      if syntax.block_required?
        error "block is required for //#{syntax.name}; use empty block"
      end
      []
    end

    def compile_single(syntax, args)
      @strategy.__send__(syntax.name, *args)
    end



    def compile_inline(op, arg)
      unless inline_defined?(op)
        raise CompileError, "no such inline op: #{op}"
      end
      unless @strategy.respond_to?("inline_#{op}")
        raise "strategy does not support inline op: @<#{op}>"
      end
      @strategy.__send__("inline_#{op}", arg)
    rescue => err
      error err.message
    end

    def compile_paragraph(buf)
      @strategy.paragraph buf
    end

    def warn(msg)
      @strategy.warn msg
    end

    def error(msg)
      @strategy.error msg
    end


}

root = Start

Start = &. { tagged_section_init } Block* { close_all_tagged_section }


## TODO InlineElement の後に Ulist / Olist / Dlist が来ると先頭行じゃなくてマッチできてしまうかも
## using &. to detect EOF
Block = BlankLine*
        ( SinglelineComment:c
        | Headline:headline
        | BlockElement:c
        | Ulist:c
        | Olist:c
        | Dlist:c
        | Paragraph:c
        )

BlankLine = Newline

Headline = ( HeadlinePrefix:level BracketArg?:cmd BraceArg?:label Space* SinglelineContent:caption Newline* )  { compile_headline(level, cmd, label, caption) }

HeadlinePrefix = < /={1,5}/ > { text.length }

Paragraph = ParagraphSub+:c  { compile_paragraph(c) }

ParagraphSub = ( InlineElement:c { c }
               | < ContentText > { text }
               )+:d  Newline { d }

## ContentText = !Newline !Headline !SinglelineComment !BlockElement !Ulist !Olist !Dlist NonInlineElement+:c { c }
ContentText = NonInlineElement+:c { c }

NonInlineElement = !InlineElement < /[^\r\n]/ > { text }

BlockElement = ( "//" ElementName:symbol BracketArg*:args "{" Space* Newline BlockElementContents?:contents "//}" Space* Newline
               {           compile_command(symbol, args, contents) }
               | "//" ElementName:symbol BracketArg*:args Space* Newline
               )

InlineElement =  "@<" < /[^>\r\n]+/ > {symbol = text} ">" "{" < InlineElementContents? > { contents = text } "}"
                 { compile_inline(symbol,contents); }

BracketArg = "[" < /([^\r\n\]\\]|\\[^\r\n])*/ > "]" { text }

BraceArg = "{" < /([^\r\n}\\]|\\[^\r\n])*/ > "}" { text }

## contents との差は paragraph を切るか切らないか
BlockElementContents = BlockElementContent+:c

## 各要素は Newline で終わらなければならない
BlockElementContent = ( SinglelineComment:c
                      | BlockElement:c
                      | BlockElementParagraph:c
                      )

BlockElementParagraph = &. { @blockElem = [] } BlockElementParagraphSub+:c { @blockElem }

BlockElementParagraphSub = ( InlineElement:c { @blockElem << c }
                           | BlockElementContentText:c { @blockElem << c }
                           )+ Newline

BlockElementContentText = !"//}" !SinglelineComment !BlockElement !Ulist !Olist !Dlist  < NonInlineElement+ >  { text }

InlineElementContents = !"}" InlineElementContent+:c { c }

InlineElementContent = ( InlineElement:c
                       | InlineElementContentText:c
                       )

InlineElementContentText = ( !InlineElement /[^\r\n}]/ )+

SinglelineContent = ContentInlines:c (Newline | EOF) { c }

ContentInlines =  ContentInline+:c  { c.join }

ContentInline = ( InlineElement:c { c }
                | !Newline < /[^\r\n]/ > {text }
                )

## ContentInlineText = !InlineElement !Newline  .:cc { p [:char,cc];cc }


## * 箇条書き
## 行頭から… の指定がない

Ulist =  &. { @ulist_elem=[] } (UlistElement | SinglelineComment)+ (Newline | EOF) { compile_ulist(@ulist_elem) }

UlistElement = " "+ "*"+:level " "* SinglelineContent:c { @ulist_elem << [level.size, c] }

## 1. 番号付き箇条書き
## 行頭から… の指定がない

Olist = { @olist_elem = [] } (OlistElement | SinglelineComment)+:c { compile_olist(@olist_elem) }

OlistElement = " "+ < /\d/+ > { level=text } "." Space* SinglelineContent:c {@olist_elem << [level, c] }

## : 用語リスト
  ## 行頭から… の指定がない
Dlist = (DlistElement | SinglelineComment):c Dlist?:cc

DlistElement = " "* ":" " " Space* SinglelineContent:text DlistElementContent:content

DlistElementContent = /[ \t]+/ SinglelineContent:c

SinglelineComment = ("#@" < NonNewLine > { comment(text) } Newline)

NonNewLine = /[^\r\n]+/

Digits = Digit+:c { c }

## Space = /[ 　\t]/
Space = /[ \t]/

EOF = !.

ElementName = < LowerAlphabetAscii+ > { text }

%literals         = ReVIEW::Compiler::Literals
Alphanumeric      = %literals.Alphanumeric
AlphanumericAscii = %literals.AlphanumericAscii
LowerAlphabetAscii = %literals.LowerAlphabetAscii
Digit              = %literals.Digit
BOM               = %literals.BOM
Newline           = %literals.Newline
NonAlphanumeric   = %literals.NonAlphanumeric
Spacechar         = %literals.Spacechar
